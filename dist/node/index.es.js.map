{"version":3,"file":"index.es.js","sources":["../../src/node/file.js","../../src/node/image.js","../../src/variables.js"],"sourcesContent":["import { createHash } from 'crypto'\nimport fs from 'fs'\nimport { join, extname, parse } from 'path'\n\n// eslint-disable-next-line no-new-func\nexport const isNode = new Function('try {return this===global;}catch(e){return false;}')\n\n// eslint-disable-next-line no-new-func\nexport const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n/**\n * @function fileHash\n * @param {string} filename\n * @param {'sha1'|'md5'|'sha256'|'sha512'} algorithm\n * @returns {Promise<string>|false}\n */\nexport async function fileHash(filename, algorithm = 'md5') {\n  if (isBrowser()) return false\n  const result = new Promise((resolve, reject) => {\n    try {\n      const shasum = createHash(algorithm)\n      const s = fs.ReadStream(filename)\n      s.on('data', data => shasum.update(data))\n\n      // making digest\n      s.on('end', () => {\n        const hash = shasum.digest('hex')\n        return resolve(hash)\n      })\n    } catch (error) {\n      return reject(error)\n    }\n  })\n\n  return result\n}\n\n/**\n * using path.parse\n * @function fileParse\n * @param {String} filePath\n * @returns {import('path').ParsedPath}\n */\nexport function fileParse(filePath) {\n  if (isNode()) {\n    return filePath && parse(filePath)\n  }\n}\n\n/**\n * @function pathJoin\n * @param {...string} paths\n * @returns {string}\n */\nexport function pathJoin(...paths) {\n  if (isNode()) {\n    return join(...paths)\n  }\n}\n\n/**\n * using path.extname\n * @function extName\n * @param {string} filePath\n * @returns {string} extension ex: '.png'\n */\nexport function extName(filePath) {\n  if (isNode()) {\n    return extname(filePath) || ''\n  }\n}\n\n/**\n * @function fileExists\n * @param {string} filePath\n * @returns {boolean}\n */\nexport function fileExists(filePath) {\n  try {\n    if (isNode()) {\n      return !!fs.existsSync(filePath)\n    }\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * @function deleteFile\n * @param {string} filePath\n * @returns {Promise<Boolean>}\n */\nexport async function deleteFile(filePath) {\n  try {\n    if (isNode() && fileExists(filePath)) fs.unlinkSync(filePath)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n\n/**\n * @function renameFile\n * @param {String} oldPath\n * @param {String} newPath\n * @param {Boolean} force\n * @returns {Boolean}\n */\nexport function renameFile(oldPath, newPath, force) {\n  try {\n    if (isNode()) {\n      if (force && fileExists(newPath)) {\n        fs.unlinkSync(newPath)\n      }\n      fs.renameSync(oldPath, newPath)\n      return true\n    }\n    return false\n  } catch (_error) {\n    return false\n  }\n}\n\n/**\n * @function copyFile\n * @param {string} source\n * @param {string} target\n * @returns {Promise<boolean>}\n */\nexport async function copyFile(source, target) {\n  if (isBrowser()) return false\n\n  const result = await new Promise(resolve => {\n    fs.copyFile(source, target, err => {\n      if (err) return resolve(false)\n      return resolve(true)\n    })\n  })\n  return result\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport { isModuleResolve } from '../variables'\n\n/**\n * @function toBase64Img\n */\nexport function toBase64Img(filePath) {\n  const base64 = isModuleResolve('base64-img') && require('base64-img')\n  return base64 && base64.base64Sync(filePath)\n  // }\n}\n","export function isModuleResolve(moduleName) {\n  try {\n    return !!require.resolve(moduleName)\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    return console.error(`'${moduleName}' is not found`) && false\n  }\n}\n\nexport function isDefined(v) {\n  try {\n    return !!(v !== null && v !== undefined)\n  } catch (error) {\n    return false\n  }\n}\n\nexport function notNull(value, defaultValue = true) {\n  return value === undefined || value === null ? defaultValue : value\n}\n\n/**\n * Convert Int To String(Hex)\n * @param {Number} int\n * @param {Number} size integer\n * @param {Boolean} noLeftZero\n * @returns {string} hex(number)\n */\nexport function intToHex(int, size, noLeftZero) {\n  const rmL = s => s.replace(/^0+/, '')\n  try {\n    const hex = Number(int).toString(16).toLocaleUpperCase()\n    const len = hex.length % 2 !== 0 ? hex.length + 1 : hex.length\n    return noLeftZero ? rmL(hex) : hex.padStart(size || len, '0')\n  } catch (e) {\n    const rtn = '00'\n    return noLeftZero ? rmL(rtn) : rtn.padStart(size || 2, '0')\n  }\n}\n\n/**\n * Convert Int To String(Hex)\n * @param {Number} int\n * @returns {string} hex(number)\n */\nexport function intToHex2(int) {\n  try {\n    const hex = Number(int).toString(16).toLocaleUpperCase()\n    const len = hex.length % 2 !== 0 ? hex.length + 1 : hex.length\n    return hex.padStart(len, '0')\n  } catch (e) {\n    return `0${(0).toString(16)}`.slice(-2).toUpperCase()\n  }\n}\n/**\n * @function tryInteger\n * @param {any} value\n * @returns {Number|False}\n */\nexport function tryInteger(value) {\n  const numero = parseInt(value, 10)\n  if (Number.isInteger(numero) || numero <= 0) return numero\n  return false\n}\n\n/**\n * Converte Hexadecimal em Alphanumeric String\n * @function hexToAlphaNumeric\n * @param {Buffer | String | Array<String>} hexx\n * @param {Boolean} preserve se true converte invalid ALPHANUMERIC in space\n * @returns {String} hexadecimal string\n * @example\n * hexToAlphaNumeric('414243') // return 'ABC'\n * hexToAlphaNumeric('413943', true) // return 'A C'\n */\nexport function hexToAlphaNumeric(hexx, preserve) {\n  try {\n    if (!hexx) return ''\n    let hex = ''\n    if (hexx instanceof Buffer) hex = hexx.toString('hex').toUpperCase()\n    if (Array.isArray(hexx)) hex = hexx.join('').toUpperCase()\n    hex = require('chunk')(hex, 2)\n    let result = ''\n    for (let i = 0; i < hex.length; i++) {\n      const h = hex[i]\n      const num = hexToInt(h)\n      if (preserve) {\n        result += num >= 40 && num <= 126 ? String.fromCharCode(num) : ' '\n      } else if (num >= 40 && num <= 126) result += String.fromCharCode(num)\n    }\n    return result\n  } catch (error) {\n    throw new Error('install module \"chunk\"')\n  }\n}\n\nexport function hex2a(hexx) {\n  const hex = hexx.toString() // force conversion\n  let str = ''\n  for (let i = 0; i < hex.length && hex.substr(i, 2) !== '00'; i += 2) {\n    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16))\n  }\n  return str\n}\n\n/**\n * Convert HEX To String UTF-8\n * @param {Buffer} hex\n * @returns {string} ASCII(hex)\n */\nexport function hexToASC(hex) {\n  try {\n    if (hex instanceof Buffer) {\n      return hex.toString('utf8')\n    }\n    if (Array.isArray(hex)) return Buffer.from(hex.join(''), 'hex').toString('utf8')\n    return Buffer.from(hex, 'hex').toString('utf8')\n  } catch (error) {\n    return ''\n  }\n}\n\n/**\n * Convert ASCII To String(Hex)\n * @param {String} str\n * @returns {string} hex(number)\n */\nexport function ASCToHex(str) {\n  const arr1 = []\n  for (let n = 0, l = str.length; n < l; n++) {\n    const hex = Number(str.charCodeAt(n)).toString(16)\n    arr1.push(hex)\n  }\n  return arr1.join('')\n}\n\n/**\n * @function hexToInt\n * @param {String | Array} strhex\n * @returns {Number} decimal ASCII\n * @example\n * hexToInt('41'); // return 'A'\n * hexToInt(['41','42','43']); // return ['A','B','C']\n */\nexport function hexToInt(strhex) {\n  if (Array.isArray(strhex)) return strhex.map(item => hexToInt(item))\n  try {\n    const result = parseInt(strhex, 16)\n    return result\n  } catch (error) {\n    return 0\n  }\n}\n"],"names":["isNode","Function","isBrowser","async","fileHash","filename","algorithm","Promise","resolve","reject","shasum","createHash","s","fs","ReadStream","on","data","update","hash","digest","error","fileParse","filePath","parse","pathJoin","paths","join","extName","extname","fileExists","existsSync","err","deleteFile","unlinkSync","_error","renameFile","oldPath","newPath","force","renameSync","copyFile","source","target","toBase64Img","base64","moduleName","require","e","console","isModuleResolve","base64Sync"],"mappings":"gHAKaA,EAAS,IAAIC,SAAS,sDAGtBC,EAAY,IAAID,SAAS,uDAQ/BE,eAAeC,EAASC,EAAUC,EAAY,UAC/CJ,IAAa,OAAO,SACT,IAAIK,SAAQ,CAACC,EAASC,eAE3BC,EAASC,EAAWL,GACpBM,EAAIC,EAAGC,WAAWT,GACxBO,EAAEG,GAAG,QAAQC,GAAQN,EAAOO,OAAOD,KAGnCJ,EAAEG,GAAG,OAAO,WACJG,EAAOR,EAAOS,OAAO,cACpBX,EAAQU,MAEjB,MAAOE,UACAX,EAAOW,OAab,SAASC,EAAUC,MACpBtB,WACKsB,GAAYC,EAAMD,GAStB,SAASE,KAAYC,MACtBzB,WACK0B,KAAQD,GAUZ,SAASE,EAAQL,MAClBtB,WACK4B,EAAQN,IAAa,GASzB,SAASO,EAAWP,UAEnBtB,YACOa,EAAGiB,WAAWR,GAEzB,MAAOS,UACA,GASJ5B,eAAe6B,EAAWV,cAEzBtB,KAAY6B,EAAWP,IAAWT,EAAGoB,WAAWX,IAC7C,EACP,MAAOY,UACA,GAWJ,SAASC,EAAWC,EAASC,EAASC,eAErCtC,MACEsC,GAAST,EAAWQ,IACtBxB,EAAGoB,WAAWI,GAEhBxB,EAAG0B,WAAWH,EAASC,IAChB,GAGT,MAAOH,UACA,GAUJ/B,eAAeqC,EAASC,EAAQC,MACjCxC,IAAa,OAAO,eAEH,IAAIK,SAAQC,IAC/BK,EAAG2B,SAASC,EAAQC,GAAQX,GACVvB,GAAZuB,QChIH,SAASY,EAAYrB,SACpBsB,ECPD,SAAyBC,eAEnBC,QAAQtC,QAAQqC,GACzB,MAAOE,UAEAC,QAAQ5B,MAAO,IAAGyB,qBAA+B,GDE3CI,CAAgB,eAAiBH,QAAQ,qBACjDF,GAAUA,EAAOM,WAAW5B"}